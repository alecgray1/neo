//! Exposed Function Metadata
//!
//! This module contains metadata types for functions exposed via the `#[neo::expose]` macro.

use serde::{Deserialize, Serialize};

/// Metadata about an exposed function
///
/// This struct is generated by the `#[neo::expose]` macro and contains
/// all the information needed to register the function in each target:
/// - JavaScript (QuickJS)
/// - Blueprints (visual scripting)
/// - TypeScript (type definitions)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExposedFunction {
    /// The name the function is exposed as
    pub name: String,

    /// Documentation for the function (from doc comments)
    pub description: Option<String>,

    /// Whether this function is exposed to JavaScript
    pub js_enabled: bool,

    /// Whether this function is exposed to Blueprints
    pub blueprint_enabled: bool,

    /// Whether TypeScript definitions are generated
    pub typescript_enabled: bool,

    /// Category for blueprint node organization
    pub category: String,

    /// Whether this is a pure function (no side effects)
    pub pure: bool,

    /// The TypeScript type definition string
    pub typescript_def: String,
}

impl ExposedFunction {
    /// Create a new ExposedFunction with default settings
    pub fn new(name: impl Into<String>) -> Self {
        let name = name.into();
        Self {
            typescript_def: format!("declare function {}(): void;", name),
            name,
            description: None,
            js_enabled: true,
            blueprint_enabled: true,
            typescript_enabled: true,
            category: "Uncategorized".to_string(),
            pure: false,
        }
    }

    /// Set the description
    pub fn with_description(mut self, desc: impl Into<String>) -> Self {
        self.description = Some(desc.into());
        self
    }

    /// Set the category
    pub fn with_category(mut self, category: impl Into<String>) -> Self {
        self.category = category.into();
        self
    }

    /// Set whether this is a pure function
    pub fn pure(mut self, pure: bool) -> Self {
        self.pure = pure;
        self
    }

    /// Set the TypeScript definition
    pub fn with_typescript_def(mut self, def: impl Into<String>) -> Self {
        self.typescript_def = def.into();
        self
    }

    /// Disable JavaScript exposure
    pub fn disable_js(mut self) -> Self {
        self.js_enabled = false;
        self
    }

    /// Disable Blueprint exposure
    pub fn disable_blueprint(mut self) -> Self {
        self.blueprint_enabled = false;
        self
    }

    /// Disable TypeScript generation
    pub fn disable_typescript(mut self) -> Self {
        self.typescript_enabled = false;
        self
    }
}

/// Registry for exposed functions
///
/// Collects all functions exposed via `#[neo::expose]` and provides
/// methods to generate bindings for each target.
#[derive(Debug, Default)]
pub struct ExposedRegistry {
    functions: Vec<ExposedFunction>,
}

impl ExposedRegistry {
    /// Create a new empty registry
    pub fn new() -> Self {
        Self::default()
    }

    /// Register an exposed function
    pub fn register(&mut self, func: ExposedFunction) {
        self.functions.push(func);
    }

    /// Get all registered functions
    pub fn functions(&self) -> &[ExposedFunction] {
        &self.functions
    }

    /// Get functions that are exposed to JavaScript
    pub fn js_functions(&self) -> impl Iterator<Item = &ExposedFunction> {
        self.functions.iter().filter(|f| f.js_enabled)
    }

    /// Get functions that are exposed to Blueprints
    pub fn blueprint_functions(&self) -> impl Iterator<Item = &ExposedFunction> {
        self.functions.iter().filter(|f| f.blueprint_enabled)
    }

    /// Generate TypeScript declarations for all exposed functions
    pub fn generate_typescript(&self) -> String {
        let mut output = String::new();
        output.push_str("// Auto-generated TypeScript definitions\n");
        output.push_str("// Do not edit manually\n\n");
        output.push_str("declare namespace neo {\n");

        for func in self.functions.iter().filter(|f| f.typescript_enabled) {
            if let Some(ref desc) = func.description {
                output.push_str(&format!("  /** {} */\n", desc));
            }
            // Remove "declare " prefix since we're inside namespace
            let ts_def = func.typescript_def.replace("declare ", "  ");
            output.push_str(&format!("{}\n", ts_def));
        }

        output.push_str("}\n");
        output
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_exposed_function_builder() {
        let func = ExposedFunction::new("test_func")
            .with_description("A test function")
            .with_category("Testing")
            .pure(true);

        assert_eq!(func.name, "test_func");
        assert_eq!(func.description, Some("A test function".to_string()));
        assert_eq!(func.category, "Testing");
        assert!(func.pure);
        assert!(func.js_enabled);
        assert!(func.blueprint_enabled);
        assert!(func.typescript_enabled);
    }

    #[test]
    fn test_exposed_registry() {
        let mut registry = ExposedRegistry::new();

        registry.register(ExposedFunction::new("func1").with_category("Math"));
        registry.register(ExposedFunction::new("func2").disable_js());
        registry.register(ExposedFunction::new("func3").disable_blueprint());

        assert_eq!(registry.functions().len(), 3);
        assert_eq!(registry.js_functions().count(), 2);
        assert_eq!(registry.blueprint_functions().count(), 2);
    }

    #[test]
    fn test_typescript_generation() {
        let mut registry = ExposedRegistry::new();

        registry.register(
            ExposedFunction::new("add")
                .with_description("Add two numbers")
                .with_typescript_def("declare function add(a: number, b: number): number;"),
        );

        let ts = registry.generate_typescript();
        assert!(ts.contains("namespace neo"));
        assert!(ts.contains("Add two numbers"));
        assert!(ts.contains("function add(a: number, b: number): number"));
    }
}
