//! TypeScript Bridge
//!
//! Generates and updates TypeScript declaration files (.d.ts) when
//! types change in the TypeRegistry. This provides IDE support similar
//! to how Nuxt regenerates types.

use std::path::PathBuf;
use std::sync::Arc;

use tokio::fs;
use tokio::sync::broadcast;

use blueprint_types::{FieldDef, PinType, TypeCategory, TypeChange, TypeDef, TypeRegistry};

/// Bridge that syncs TypeRegistry to TypeScript declaration files
pub struct TypeScriptBridge {
    /// Path to the output .d.ts file
    output_path: PathBuf,

    /// Reference to the type registry
    type_registry: Arc<TypeRegistry>,

    /// Shutdown signal
    shutdown: broadcast::Sender<()>,
}

impl TypeScriptBridge {
    /// Create a new TypeScript bridge
    pub fn new(type_registry: Arc<TypeRegistry>, output_path: impl Into<PathBuf>) -> Self {
        let (shutdown, _) = broadcast::channel(1);
        Self {
            output_path: output_path.into(),
            type_registry,
            shutdown,
        }
    }

    /// Start the bridge, listening for type changes
    pub async fn start(&self) -> Result<(), std::io::Error> {
        // Generate initial types
        self.regenerate().await?;

        // Subscribe to changes
        let mut changes = self.type_registry.subscribe();
        let mut shutdown = self.shutdown.subscribe();

        loop {
            tokio::select! {
                _ = shutdown.recv() => {
                    tracing::info!("TypeScript bridge shutting down");
                    break;
                }
                result = changes.recv() => {
                    match result {
                        Ok(change) => {
                            tracing::debug!("Type change detected: {:?}", change);
                            if let Err(e) = self.regenerate().await {
                                tracing::error!("Failed to regenerate TypeScript: {}", e);
                            }
                        }
                        Err(broadcast::error::RecvError::Lagged(n)) => {
                            tracing::warn!("TypeScript bridge lagged {} messages, regenerating", n);
                            if let Err(e) = self.regenerate().await {
                                tracing::error!("Failed to regenerate TypeScript: {}", e);
                            }
                        }
                        Err(broadcast::error::RecvError::Closed) => {
                            tracing::info!("Type registry channel closed");
                            break;
                        }
                    }
                }
            }
        }

        Ok(())
    }

    /// Stop the bridge
    pub fn stop(&self) {
        let _ = self.shutdown.send(());
    }

    /// Regenerate the TypeScript declaration file
    pub async fn regenerate(&self) -> Result<(), std::io::Error> {
        let content = self.generate_declarations().await;

        // Ensure parent directory exists
        if let Some(parent) = self.output_path.parent() {
            fs::create_dir_all(parent).await?;
        }

        fs::write(&self.output_path, content).await?;
        tracing::info!("Generated TypeScript declarations: {:?}", self.output_path);

        Ok(())
    }

    /// Generate TypeScript declaration content
    async fn generate_declarations(&self) -> String {
        let mut output = String::new();

        output.push_str("// Auto-generated by Neo TypeScript Bridge\n");
        output.push_str("// Do not edit manually - changes will be overwritten\n\n");

        // Generate event types
        output.push_str("// ═══════════════════════════════════════════════════════════════════════════\n");
        output.push_str("// Event Types\n");
        output.push_str("// ═══════════════════════════════════════════════════════════════════════════\n\n");

        let events = self.type_registry.get_by_category(TypeCategory::Event).await;
        for event in events {
            output.push_str(&self.generate_interface(&event));
            output.push('\n');
        }

        // Generate object types
        output.push_str("// ═══════════════════════════════════════════════════════════════════════════\n");
        output.push_str("// Object Types\n");
        output.push_str("// ═══════════════════════════════════════════════════════════════════════════\n\n");

        let objects = self.type_registry.get_by_category(TypeCategory::Object).await;
        for object in objects {
            output.push_str(&self.generate_interface(&object));
            output.push('\n');
        }

        // Generate namespace with all types
        output.push_str("// ═══════════════════════════════════════════════════════════════════════════\n");
        output.push_str("// Neo Namespace\n");
        output.push_str("// ═══════════════════════════════════════════════════════════════════════════\n\n");

        output.push_str("declare namespace neo {\n");
        output.push_str("  namespace events {\n");
        for event in self.type_registry.get_by_category(TypeCategory::Event).await {
            let safe_name = event.name.replace(' ', "");
            output.push_str(&format!("    export type {} = {};\n", safe_name, safe_name));
        }
        output.push_str("  }\n\n");

        output.push_str("  namespace objects {\n");
        for object in self.type_registry.get_by_category(TypeCategory::Object).await {
            let safe_name = object.name.replace(' ', "");
            output.push_str(&format!("    export type {} = {};\n", safe_name, safe_name));
        }
        output.push_str("  }\n");
        output.push_str("}\n");

        output
    }

    /// Generate TypeScript interface for a type
    fn generate_interface(&self, def: &TypeDef) -> String {
        let mut output = String::new();

        // Add JSDoc comment if description exists
        if let Some(ref desc) = def.description {
            output.push_str(&format!("/** {} */\n", desc));
        }

        let safe_name = def.name.replace(' ', "");
        output.push_str(&format!("interface {} {{\n", safe_name));

        for field in &def.fields {
            let ts_type = pin_type_to_ts(&field.field_type);
            let optional = if field.optional { "?" } else { "" };
            output.push_str(&format!("  {}{}: {};\n", field.name, optional, ts_type));
        }

        output.push_str("}\n");
        output
    }
}

/// Convert a PinType to TypeScript type
fn pin_type_to_ts(pin_type: &PinType) -> String {
    match pin_type {
        PinType::Exec => "void".to_string(),
        PinType::Boolean => "boolean".to_string(),
        PinType::Integer => "number".to_string(),
        PinType::Real => "number".to_string(),
        PinType::String => "string".to_string(),
        PinType::Any => "any".to_string(),
        PinType::PointValue => "number | boolean".to_string(),
        PinType::Array { element } => format!("{}[]", pin_type_to_ts(element)),
        PinType::Struct { struct_id } => struct_id.clone(),
        PinType::Object { object_id } => object_id.clone(),
        PinType::Event { event_id } => event_id.clone(),
        PinType::Handle { target_type } => format!("Handle<{}>", target_type),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_generate_declarations() {
        let registry = Arc::new(TypeRegistry::new());

        // Register an event type
        let event = TypeDef::event("neo/ZoneAlert", "ZoneAlert")
            .add_field(FieldDef::required("zone_id", PinType::String))
            .add_field(FieldDef::required("temperature", PinType::Real))
            .with_description("Alert when zone temperature exceeds threshold");

        registry.register(event).await.unwrap();

        let bridge = TypeScriptBridge::new(registry, "/tmp/neo-test.d.ts");
        let content = bridge.generate_declarations().await;

        assert!(content.contains("interface ZoneAlert"));
        assert!(content.contains("zone_id: string"));
        assert!(content.contains("temperature: number"));
        assert!(content.contains("namespace neo"));
    }

    #[test]
    fn test_pin_type_to_ts() {
        assert_eq!(pin_type_to_ts(&PinType::Boolean), "boolean");
        assert_eq!(pin_type_to_ts(&PinType::Integer), "number");
        assert_eq!(pin_type_to_ts(&PinType::Real), "number");
        assert_eq!(pin_type_to_ts(&PinType::String), "string");
        assert_eq!(
            pin_type_to_ts(&PinType::Array {
                element: Box::new(PinType::Integer)
            }),
            "number[]"
        );
    }
}
